# DockerでWeb&APIサーバーを作ってみよう

## 目次

- このハンズオンの概要
- セットアップ
- サーバーサイドKotlin
  - サーバーサイドKotlinを実行してみよう
- Dockerとは？
- Dockerfileを書こう
  - よく使うコマンドとか
- docker-compose.ymlを書こう
  - よく使うコマンドとか
- Expose＆JacksonでDB操作しつつJSONでレスポンスしてみよう
- Reactを書いてみよう
- ngrokを使ってみよう
- おまけ
  - Slackに通知してみよう

## このハンズオンの概要

Dockerを使ってWebサーバーとAPIサーバーとDBサーバーを立てて動作させてみましょう。
Web＆APIサーバー： Kotlin
DBサーバー：  MySQL
Webサーバー: React

簡単なユーザー登録フォームと一覧取得APIを作成します。
寄り道として、Slackへの通知を実装してみます。
最後にngrokを使って自分のローカル内のサーバーをインターネット上に公開してみましょう。
一時的に他の方に見てもらったり、スマホアプリでの開発などで活用できるでしょう。

## セットアップ

以下を使用する予定なので事前にインストールお願いします。

- Java8のJDK （Kotlinに必要）
- intelliJ IDEA community edition (Ktorの開発のため)
  - Ktorプラグイン
  - お好みで必要なプラグイン
- Docker
  - アプリをダウンロードするのに会員登録あります
  - Dockerのイメージのサイズも比較的大きいので事前に以下のコマンドを実行して取得しておいてください
  - `docker pull openjdk:8-jdk-stretch`
  - `docker pull mysql:8.0`
- Visual Studio Code (React用、WebStorm等でもOK)
  - プラグイン
    - ESLint
    - Prettier
- ngrok
  - https://ngrok.com/
  - 会員登録してアプリをダウンロードする
  - ログイン後の画面の `Connect your account` に表示されているコマンドを実行してトークンを登録しておく


## サーバーサイドKotlin

### サーバーサイドKotlinを実行してみよう

サンプルプロジェクトを作成してローカルでサーバーを動かしてみましょう。  
https://ktor.io/quickstart/index.html  

上記を参考に先ずはサンプルのプロジェクトを作成しましょう。  

1. 新しいプロジェクトを作成
2. Ktorを選択し、CSS DSLとApache HttpClient Engineをチェック
3. GroupIdとArtifactIdを変更

上記のステップを実行すると、実行可能なサンプルが生成されます。  
実行可能な状態にしましょう。  

1. 右上の `Edit Configuration` を選択
2. 左上の `+` を押して `Kotlin` を選択
3. `Use class pass of module` で `プロジェクト名_main` を選択
4. `Main class` の横の `...` を選択
5. 表示されたクラス名を選択
6. Configuration名を変更
7. OK

上記のステップで作成したConfigurationを選択すると、右上の実行とデバッグが押せる様になるので実行してみましょう。  
デフォルトでは8080ポートでWebサーバーが実行されます。  
http://localhost:8080 でサーバーにアクセスできます。  

### Fat Jarを作る

Dockerで動作させるために `Fat Jar` （依存しているもの全て含んだ単体で動作するJarファイル）を作成してみましょう。
参考サイト： https://ktor.io/servers/deploy/packing/fatjar.html  

下記のプラグインを使用します。
https://github.com/johnrengelman/shadow

参考サイトを参考にしてgradleに記述を追加しましょう。  
参考サイトには何故か `kotlin-gradle-plugin` の記述がないですが、必要なので削除はしない様にしましょう。  

記述が終わったらビルド用のConfigurationを追加します。  

1. `Edit Configulation` から `+` を押して `Gradle` を選択
2. `Gradle project` の横のフォルダーをクリックしてプロジェクトを選択
3. `Tasks` に `shadowJar` と入力
4. Configuration名を変更
5. OK

上記のステップで作成したConfigurationを実行すると、 `./build/libs/` 配下にjarファイルが出来ます。  
`java -jar jarファイル` でサーバーが実行されます。  
次は上記ファイルをDockerで動かしてみましょう。 

## Dockerとは？

仮想マシンと比較すると軽量なコンテナ技術を使って隔離された環境を作り出すことが出来るサービスです。
仮想マシンはOS含めて全て動かすことで別の環境を実行していますが、コンテナはカーネルを利用しつつプロセス等を分離することで、あたかも別の環境の様に振る舞います。
そのため、仮想マシンと比較して無駄が少なく、高速に実行出来たり、含めないといけないファイルが少なく、イメージサイズが小さくなったりします。

注意ポイントとして、上記はLinux上でコンテナ技術を利用した場合のメリットとなります。
MacやWindows上でDockerを実行した場合、docker-machineやVirtualBoxなどの仮想マシンと連携して動作しています。
そのため、同じように動作はしますが純粋にコンテナ技術では動作していません。

ではDockerを使うと何が嬉しいのかと言うと、隔離された環境ごとに必要なライブラリをまとめて入れられるところにあります。
自分のローカル環境に構築する場合、AというサービスとBというサービスがそれぞれ別のバージョンのNode.jsやRubyに依存している場合、それぞれの環境に合わせて切り替えるといった運用がDockerを使用することで特に意識しなくてよくなります。
人に環境を作ってもらう時もDockerfileに必要な処理が書かれているので、大半の処理は自動でやってくれるため、環境構築が格段に簡単になります。

## Dockerfileを書こう

Dockerを動かすにはDockerfileを記載する必要があります。
先ずはDockerfileを記載しましょう。

最初にベースとなるコンテナのイメージを `FROM` で取得します。
ベースとなるイメージは[Dockerhub]("https://hub.docker.com/")を検索して見つけましょう。
セキュリティ面を考慮すると、信頼できない第三者のイメージの仕様は避け、Officialのイメージを取得する様にしましょう。

先ずはKtorが生成したjarファイルをコピーして実行するだけの簡単なDockerfileを書いてみましょう。  
事前にDockerfileと同じディレクトリにjarファイルをコピーしておいてください。

ヒント
```dockerfile
#OpenJDKのイメージを https://hub.docker.com/ から探してJAVA 8のタグを指定しましょう
FROM image:tag

#jarファイルをDockerイメージの/opt/配下にコピーします
COPY jarファイル /opt/

#処理を実行するディレクトリを/opt配下に切り替えます
WORKDIR /opt/

#/bin/sh経由で呼び出すことでワイルドカードが使えます
CMD ["/bin/sh", "-c", "java -jar jarファイル名*.jar"]
```

### よく使うコマンドとか

- `FROM image:tag` ベースとなるイメージを指定します
- `COPY source distination` ファイルをDockerのイメージ内にコピーします 圧縮されたファイルは圧縮されたままコピーされます
- `ADD source distination` ファイルをDockerのイメージ内にコピーします URLの指定ができ、圧縮されたファイルは自動で展開されます
- `RUN command` shellコマンドを実行できます 足りないパッケージをインストールしたり用途は色々
- `WORKDIR directory` Docker起動時の初期ディレクトリを指定できます
- `CMD ["command"]` Docker起動時のコマンドを指定する `[]` で括り、引数は `,` 区切りで記載します

### dockerを実行してみよう

Dockerfileを書いてもビルドしないとイメージは作成されません。  
以下のコマンドでイメージをビルドしましょう。  
`docker build --tag tag_name .`

ビルドしたイメージは以下のコマンドで動かすことが出来ます。  
今回はWebサーバーなので `p` オプションを使用してホストとDockerのポートをつなぎましょう。  

`sudo docker run -p host_port_number:docker_port_number tag_name`

http://localhost でサーバーにアクセスできます。  

## MySQLサーバー

### Ktorと連携するMySQLサーバーを実行しよう

MySQLDockerフォルダー内のDockerfileにMySQLを実行する様に記載しましょう。

```dockerfile
#MySQLのイメージを https://hub.docker.com/ から探してバージョン8のタグを指定しましょう
FROM image:tag
```

`CMD` は特に実行しなくても元のイメージが実行しているので不要です。
Docker hubのタグのリンクをクリックすると元のDockerfileを見ることが出来るので、何を実行しているのか確認出来ます。

## docker-compose.ymlを書こう

KtorとMySQLのDockerを連携しましょう。  
Dockerコマンドでも可能ですが、オプションが多くなり毎回記載するのが大変になってくるため、ここで `docker-compose` コマンドを使えるように `docker-compose.yml` を記載しましょう。

### docker-composeコマンドとは？

`docker-compose.yml` に記載したオプションや関係性を元に一度にまとめてコンテナを起動したり単独で起動したり出来る様になるコマンドです。  
単独のコンテナでも起動が楽になるので、よく使う場合記載しておくと良いでしょう。  


```yaml
version: '3.7'
# 複数のサービス（コンテナ）を記述
services:
  # サービスの名前 起動時などに指定
  kotlin:
    build: Dockerfileが入っているディレクトリを指定
    # コンテナのイメージ名とタグを指定
    image: image_name:tag
    # -pオプションで指定可能なホストとコンテナ内のポートの指定
    ports:
      - "host_port:container_port"
    # 仮想ネットワークの設定
    networks:
      # 使用するネットワーク名
      virtual_network:
        ipv4_address: IPアドレス
    container_name: 実行中のコンテナの名前
    # -vオプションで指定可能なホストとコンテナで共有するフォルダ
    volumes:
      - host_directory:container_directory
# 仮想ネットワークの設定
networks:
  # 仮想ネットワーク名
  virtual_network:
    # IP Address Managementの設定
    ipam:
      # 必要に応じてカスタムドライバーを指定可能
      driver: default
      config:
        # このネットワークが使用するサブネットを指定
        - subnet: XXX.XXX.XXX.XXX/XX
```

記述できたら `docker-compose up サービス名` で起動できるか確認しましょう。  
エラーが発生せずコンテナが立ち上がったら成功です。  
`Ctrl-C` で終了しましょう。  
`docker-compose up -d サービス名` でバックグラウンドでコンテナを立ち上げることが可能です。  

### よく使うコマンドとか

WIP...

## Exposed＆JacksonでDB操作しつつJSONでレスポンスしてみよう

[Exposed](https://github.com/JetBrains/Exposed/wiki)はKotlinを使って書かれたORMです。  
今回はこちらを使用してMySQLサーバーに接続します。  
使い方はさらっと[Getting-Started](https://github.com/JetBrains/Exposed/wiki/Getting-Started)を見て頂けるとイメージが掴みやすいかと思います。  

予め `sample` と言うデータベースを作っておく必要があるため、以下手順でデータベースを作成しましょう。
 
1. `docker-compose up -d mysql` でMySQLを立ち上げる
1. `docker-compose exec mysql mysql -h localhost -u root -p` を実行
1. パスワードを聞かれるので `docker-compose.yml` に指定した値を入力
1. mysqlのCLIが立ち上がるので `create database sample;` を実行
1. 成功したら `exit` でCLIを抜ける

今回はExposedとJacksonを使って以下の様なAPIを作成してみましょう。  

```kotlin
    // Userを追加
    post("/users") {
        // JSONを受け取って成否を返す
        if (追加成功) {
          call.respond(HttpStatusCode.OK, "")
        } else {
          call.respond(HttpStatusCode.InternalServerError, "")
        }  
    }

    get("/users") {
        // User全件をJSON型で返す
        try {
            // 取得処理
            call.respond(HttpStatusCode.OK, usersJSON)
        } catch(e: Exception){
            call.respond(HttpStatusCode.InternalServerError, "")
        }
    }

    get("/user/{id}") {
        // {id}に指定されたIDのUserをJSON型で返す
        // call.parameters["id"]でidを取得可能
        try {
            // 取得処理
            call.respond(HttpStatusCode.OK, userJSON)
        } catch(e: Exception){
            call.respond(HttpStatusCode.InternalServerError, "")
        }
    }
```



Exposedはテーブルの定義を作るとその情報を元にDBを操作できます。  
先ずはテーブル定義情報を作ります。  
model層としてパッケージを分けておくと良いでしょう。  

```kotlin
// テーブルの定義
object Users : Table() {
    val id = integer("id").autoIncrement().primaryKey() // Column<String>
    val firstName = varchar("firstName", length = 50) // Column<String>
    val lastName = varchar("lastName", length = 50) // Column<String>
    val gender = integer("gender") // Column<Int>
    val age = integer("age") // Column<Int>
}
```

DBへの接続は以下の通りです。  

```kotlin
// DBの接続情報 /以下のsampleはデータベース名
connection = Database.connect("jdbc:mysql://localhost:3306/sample", driver = "com.mysql.jdbc.Driver",
            user = DB_USER, password = DB_PASSWORD)
```

インサート処理は以下の通りです。

```kotlin
    transaction(connection) {
        SchemaUtils.create(Users)

        Users.insert {
            it[firstName] = firstName
            it[lastName] = lastName
            it[gender] = gender
            it[age] = age
        }
    }
```

全件取得の一例です。

```kotlin
    var userList = ArrayList<User>()

    transaction(connection) {
        Users.selectAll().forEach {
            userList.add(User(it[Users.firstName], it[Users.lastName], it[Users.gender], it[Users.age]))
        }
    }
```

条件指定の一例です。

```kotlin
    transaction(connection) {
        Users.select {
            Users.id eq id
        }.forEach {
            user = User(it[Users.firstName], it[Users.lastName], it[Users.gender], it[Users.age])
        }
    }

```

Jacksonを使う時は扱うJSONに対応するデータクラスを作成する必要があります。

```kotlin
class User (val id: Int, val firstName: String, val lastName: String, val gender: Int, val age: Int)
```

受け取ったJSONをデータクラスに変換する処理は以下の通りです。

```kotlin
    val userJSON = call.receiveText()
    val mapper = jacksonObjectMapper()
    try {
        val user = mapper.readValue<データクラス>(userJSON)
    } catch (e: Exception){
        // エラー処理
    }
```

データクラスをJSONのStringに変換する処理は以下の通りです。

```kotlin
    val mapper = jacksonObjectMapper()
    val usersJSON = mapper.writeValueAsString(users)

```

上記の処理を使ってAPIを書いてみましょう。

## Reactを書いてみよう

### スクレイピングしてみよう

### Slackに通知してみよう

## ngrokを使ってみよう

## k8sを使ってみよう