# DockerでWeb&APIサーバーを作ってみよう

## 目次

- このハンズオンの概要
- セットアップ
- サーバーサイドKotlin
  - サーバーサイドKotlinを実行してみよう
- Dockerとは？
- Dockerfileを書こう
  - よく使うコマンドとか
- docker-compose.ymlを書こう
  - よく使うコマンドとか
- Expose＆JacksonでDB操作しつつJSONでレスポンスしてみよう
- Reactを書いてみよう
- ngrokを使ってみよう
- おまけ
  - Slackに通知してみよう

## このハンズオンの概要

Dockerを使ってWebサーバーとAPIサーバーとDBサーバーを立てて動作させてみましょう。
Web＆APIサーバー： Kotlin
DBサーバー：  MySQL
Webサーバー: React

簡単なユーザー登録フォームと一覧取得APIを作成します。
寄り道として、Slackへの通知を実装してみます。
最後にngrokを使って自分のローカル内のサーバーをインターネット上に公開してみましょう。
一時的に他の方に見てもらったり、スマホアプリでの開発などで活用できるでしょう。

## セットアップ

以下を使用する予定なので事前にインストールお願いします。

- Java8のJDK （Kotlinに必要）
- intelliJ IDEA community edition (Ktorの開発のため)
  - Ktorプラグイン
  - お好みで必要なプラグイン
- Docker
  - アプリをダウンロードするのに会員登録あります
  - Dockerのイメージのサイズも比較的大きいので事前に以下のコマンドを実行して取得しておいてください
  - `docker pull openjdk:8-jdk-stretch`
  - `docker pull mysql:8.0`
- Visual Studio Code (React用、WebStorm等でもOK)
  - プラグイン
    - ESLint
    - Prettier
- ngrok
  - https://ngrok.com/
  - 会員登録してアプリをダウンロードする
  - ログイン後の画面の `Connect your account` に表示されているコマンドを実行してトークンを登録しておく


## サーバーサイドKotlin

### サーバーサイドKotlinを実行してみよう

サンプルプロジェクトを作成してローカルでサーバーを動かしてみましょう。  
https://ktor.io/quickstart/index.html  

上記を参考に先ずはサンプルのプロジェクトを作成しましょう。  

1. 新しいプロジェクトを作成
2. Ktorを選択し、CSS DSLとApache HttpClient Engineをチェック
3. GroupIdとArtifactIdを変更

上記のステップを実行すると、実行可能なサンプルが生成されます。  
実行可能な状態にしましょう。  

1. 右上の `Edit Configuration` を選択
2. 左上の `+` を押して `Kotlin` を選択
3. `Use class pass of module` で `プロジェクト名.main` を選択
4. `Main class` の横の `...` を選択
5. 表示されたクラス名を選択
6. Configuration名を変更
7. OK

上記のステップで作成したConfigurationを選択すると、右上の実行とデバッグが押せる様になるので実行してみましょう。  
デフォルトでは8080ポートでWebサーバーが実行されます。  
http://localhost:8080 でサーバーにアクセスできます。  

### Fat Jarを作る

Dockerで動作させるために `Fat Jar` （依存しているもの全て含んだ単体で動作するJarファイル）を作成してみましょう。
参考サイト： https://ktor.io/servers/deploy/packing/fatjar.html  

下記のプラグインを使用します。
https://github.com/johnrengelman/shadow

参考サイトを参考にしてgradleに記述を追加しましょう。  
参考サイトには何故か `kotlin-gradle-plugin` の記述がないですが、必要なので削除はしない様にしましょう。  

記述が終わったらビルド用のConfigurationを追加します。  

1. `Edit Configulation` から `+` を押して `Gradle` を選択
2. `Gradle project` の横のフォルダーをクリックしてプロジェクトを選択
3. `Tasks` に `shadowJar` と入力
4. Configuration名を変更
5. OK

上記のステップで作成したConfigurationを実行すると、 `./build/libs/` 配下にjarファイルが出来ます。  
`java -jar jarファイル` でサーバーが実行されます。  
次は上記ファイルをDockerで動かしてみましょう。 

## Dockerとは？

仮想マシンと比較すると軽量なコンテナ技術を使って隔離された環境を作り出すことができるサービスです。
仮想マシンはOS含めて全て動かすことで別の環境を実行していますが、コンテナはカーネルを利用しつつプロセス等を分離することで、あたかも別の環境の様に振る舞います。
そのため、仮想マシンと比較して無駄が少なく、高速に実行出来たり、含めないといけないファイルが少なく、イメージサイズが小さくなったりします。

注意ポイントとして、上記はLinux上でコンテナ技術を利用した場合のメリットとなります。
MacやWindows上でDockerを実行した場合、docker-machineやVirtualBoxなどの仮想マシンと連携して動作しています。
そのため、同じように動作はしますが純粋にコンテナ技術では動作していません。

ではDockerを使うと何が嬉しいのかと言うと、隔離された環境ごとに必要なライブラリをまとめて入れられるところにあります。
自分のローカル環境に構築する場合、AというサービスとBというサービスがそれぞれ別のバージョンのNode.jsやRubyに依存している場合、それぞれの環境に合わせて切り替えるといった運用がDockerを使用することで特に意識しなくてよくなります。
人に環境を作ってもらう時もDockerfileに必要な処理が書かれているので、大半の処理は自動でやってくれるため、環境構築が格段に簡単になります。

## Dockerfileを書こう

Dockerを動かすにはDockerfileを記載する必要があります。
先ずはDockerfileを記載しましょう。

最初にベースとなるコンテナのイメージを `FROM` で取得します。
ベースとなるイメージは[Dockerhub]("https://hub.docker.com/")を検索して見つけましょう。
セキュリティ面を考慮すると、信頼できない第三者のイメージの仕様は避け、Officialのイメージを取得する様にしましょう。

先ずはKtorが生成したjarファイルをコピーして実行するだけの簡単なDockerfileを書いてみましょう。  
事前にDockerfileと同じディレクトリにjarファイルをコピーしておいてください。

ヒント
```dockerfile
#OpenJDKのイメージを https://hub.docker.com/ から探してJAVA 8のタグを指定しましょう
FROM image:tag

#jarファイルをDockerイメージの/opt/配下にコピーします
COPY jarファイル /opt/

#処理を実行するディレクトリを/opt配下に切り替えます
WORKDIR /opt/

#/bin/sh経由で呼び出すことでワイルドカードが使えます
CMD ["/bin/sh", "-c", "java -jar jarファイル名*.jar"]
```

### よく使うコマンドとか

- `FROM image:tag` ベースとなるイメージを指定します
- `COPY source distination` ファイルをDockerのイメージ内にコピーします 圧縮されたファイルは圧縮されたままコピーされます
- `ADD source distination` ファイルをDockerのイメージ内にコピーします URLの指定ができ、圧縮されたファイルは自動で展開されます
- `RUN command` shellコマンドを実行できます 足りないパッケージをインストールしたり用途は色々
- `WORKDIR directory` Docker起動時の初期ディレクトリを指定できます
- `CMD ["command"]` Docker起動時のコマンドを指定する `[]` で括り、引数は `,` 区切りで記載します

### dockerを実行してみよう

Dockerfileを書いてもビルドしないとイメージは作成されません。  
以下のコマンドでイメージをビルドしましょう。  
`docker build --tag tag_name .`

ビルドしたイメージは以下のコマンドで動かすことが出来ます。  
今回はWebサーバーなので `p` オプションを使用してホストとDockerのポートをつなぎましょう。  

`sudo docker run -p host_port_number:docker_port_number tag_name`

http://localhost でサーバーにアクセスできます。  

## MySQLサーバー

### Ktorと連携するMySQLサーバーを実行しよう

MySQLDockerフォルダー内のDockerfileにMySQLを実行する様に記載しましょう。

```dockerfile
#MySQLのイメージを https://hub.docker.com/ から探してバージョン8のタグを指定しましょう
FROM image:tag
```

`CMD` は特に実行しなくても元のイメージが実行しているので不要です。
Docker hubのタグのリンクをクリックすると元のDockerfileを見ることができるので、何を実行しているのか確認出来ます。

## docker-compose.ymlを書こう

KtorとMySQLのDockerを連携しましょう。  
Dockerコマンドでも可能ですが、オプションが多くなり毎回記載するのが大変になってくるため、ここで `docker-compose` コマンドを使えるように `docker-compose.yml` を記載しましょう。

### docker-composeコマンドとは？

`docker-compose.yml` に記載したオプションや関係性を元に一度にまとめてコンテナを起動したり単独で起動したりできる様になるコマンドです。  
単独のコンテナでも起動が楽になるので、よく使う場合記載しておくと良いでしょう。  


```yaml
version: '3.3'
# 複数のサービス（コンテナ）を記述
services:
  # サービスの名前 起動時などに指定
  kotlin:
    build: Dockerfileが入っているディレクトリを指定
    # コンテナのイメージ名とタグを指定
    image: image_name:tag
    # -pオプションで指定可能なホストとコンテナ内のポートの指定
    ports:
      - "host_port:container_port"
    # 仮想ネットワークの設定
    networks:
      # 使用するネットワーク名
      virtual_network:
        ipv4_address: IPアドレス
    container_name: 実行中のコンテナの名前
    # -vオプションで指定可能なホストとコンテナで共有するフォルダ
    volumes:
      - host_directory:container_directory
  mysql:
    build: Dockerfileが入っているディレクトリを指定
    image: image_name:tag
    ports:
      - "host_port:container_port"
    networks:
      virtual_network:
        ipv4_address: IPアドレス
    container_name: 実行中のコンテナの名前
    # 環境変数の設定
    environment:
      # MySQLのコンテナはrootのパスワードを指定できる
      # 詳しくはDockerhubのイメージの公式ページを参照
      MYSQL_ROOT_PASSWORD: パスワード
    volumes:
      - host_directory:container_directory
# 仮想ネットワークの設定
networks:
  # 仮想ネットワーク名
  virtual_network:
    # IP Address Managementの設定
    ipam:
      # 必要に応じてカスタムドライバーを指定可能
      driver: default
      config:
        # このネットワークが使用するサブネットを指定
        - subnet: XXX.XXX.XXX.XXX/XX
```

記述できたら `docker-compose up サービス名` で起動できるか確認しましょう。  
エラーが発生せずコンテナが立ち上がったら成功です。  
`Ctrl-C` で終了しましょう。  
`docker-compose up -d サービス名` でバックグラウンドでコンテナを立ち上げることが可能です。  

### よく使うコマンドとか

WIP...

## Exposed＆JacksonでDB操作しつつJSONでレスポンスしてみよう

[Exposed](https://github.com/JetBrains/Exposed/wiki)はKotlinを使って書かれたORMです。  
今回はこちらを使用してMySQLサーバーに接続します。  
使い方はさらっと[Getting-Started](https://github.com/JetBrains/Exposed/wiki/Getting-Started)を見て頂けるとイメージが掴みやすいかと思います。  

予め `sample` と言うデータベースを作っておく必要があるため、以下手順でデータベースを作成しましょう。
 
1. `docker-compose up -d mysql` でMySQLを立ち上げる
1. `docker-compose exec mysql mysql -h localhost -u root -p` を実行
1. パスワードを聞かれるので `docker-compose.yml` に指定した値を入力
1. mysqlのCLIが立ち上がるので `create database sample;` を実行
1. 成功したら `exit` でCLIを抜ける

今回はExposedとJacksonを使って以下の様なAPIを作成してみましょう。  

```kotlin
    // Userを追加
    post("/users") {
        // JSONを受け取って成否を返す
        if (追加成功) {
          call.respond(HttpStatusCode.OK, "")
        } else {
          call.respond(HttpStatusCode.InternalServerError, "")
        }  
    }

    get("/users") {
        // User全件をJSON型で返す
        try {
            // 取得処理
            call.respond(HttpStatusCode.OK, usersJSON)
        } catch(e: Exception){
            call.respond(HttpStatusCode.InternalServerError, "")
        }
    }

    get("/user/{id}") {
        // {id}に指定されたIDのUserをJSON型で返す
        // call.parameters["id"]でidを取得可能
        try {
            // 取得処理
            call.respond(HttpStatusCode.OK, userJSON)
        } catch(e: Exception){
            call.respond(HttpStatusCode.InternalServerError, "")
        }
    }
```



Exposedはテーブルの定義を作るとその情報を元にDBを操作できます。  
先ずはテーブル定義情報を作ります。  
model層としてパッケージを分けておくとよいでしょう。  

```kotlin
// テーブルの定義
object Users : Table() {
    val id = integer("id").autoIncrement().primaryKey() // Column<String>
    val firstName = varchar("firstName", length = 50) // Column<String>
    val lastName = varchar("lastName", length = 50) // Column<String>
    val gender = integer("gender") // Column<Int>
    val age = integer("age") // Column<Int>
}
```

DBへの接続は以下の通りです。  

```kotlin
// DBの接続情報 /以下のsampleはデータベース名に置き換える
connection = Database.connect("jdbc:mysql://localhost:3306/sample", driver = "com.mysql.jdbc.Driver",
            user = DB_USER, password = DB_PASSWORD)
```

インサート処理は以下の通りです。

```kotlin
    transaction(connection) {
        SchemaUtils.create(Users)

        Users.insert {
            it[firstName] = firstName
            it[lastName] = lastName
            it[gender] = gender
            it[age] = age
        }
    }
```

全件取得の一例です。

```kotlin
    var userList = ArrayList<User>()

    transaction(connection) {
        Users.selectAll().forEach {
            userList.add(User(it[Users.firstName], it[Users.lastName], it[Users.gender], it[Users.age]))
        }
    }
```

条件指定の一例です。

```kotlin
    transaction(connection) {
        Users.select {
            Users.id eq id
        }.forEach {
            user = User(it[Users.firstName], it[Users.lastName], it[Users.gender], it[Users.age])
        }
    }

```

Jacksonを使う時は扱うJSONに対応するデータクラスを作成する必要があります。

```kotlin
class User (val id: Int, val firstName: String, val lastName: String, val gender: Int, val age: Int)
```

受け取ったJSONをデータクラスに変換する処理は以下の通りです。

```kotlin
    val userJSON = call.receiveText()
    val mapper = jacksonObjectMapper()
    try {
        val user = mapper.readValue<データクラス>(userJSON)
    } catch (e: Exception){
        // エラー処理
    }
```

データクラスをJSONのStringに変換する処理は以下の通りです。

```kotlin
    val mapper = jacksonObjectMapper()
    val usersJSON = mapper.writeValueAsString(users)

```

上記の処理を使ってAPIを書いてみましょう。  
POSTのテストはcurlを使うとよいでしょう。  
`curl -d '{"firstName":"test", "lastName":"user", "gender": 1, "age": 21}' -H "Content-Type: application/json" -X POST http://localhost:8080/users`  

### CORSを設定する

CORSとはCross-Origin Resource Sharingの略称です。  
ブラウザからのAPIリクエストはセキュリティを考慮して基本的にはSame-Origin（リクエスト元とリクエスト先が同じOrigin＝ドメイン）でないと呼び出すことはできません。  
しかし、今回の構成はAPIサーバーとReactを実行しているサーバーが別環境のため、このままではAPIが呼び出せません。  
そのため、CORSを設定する必要があります。  
`Application.kt` に下記のようにCORSを設定してください。  

```kotlin
fun Application.module(testing: Boolean = false) {
    val userRepository = UserRepository()

    install(CORS) {
        anyHost()
    }

...
```

上記例では全てのホストから受け付けるように設定していますが、公開APIでない場合はきちんと自社のオリジンを設定してください。  

### API実装後にFatJarを作る

上記まで実装してIDEで動かしてみて期待通りの動作ができたら再度FatJarを作ってみましょう。  
その前に一箇所MySQLのIPアドレスを、Docker内部のIPに修正します。  

変更前：  
`connection = Database.connect("jdbc:mysql://localhost:3306/sample", driver = "com.mysql.jdbc.Driver",`  
変更後：  
`connection = Database.connect("jdbc:mysql://172.28.0.2:3306/sample", driver = "com.mysql.jdbc.Driver",`

注意：IPアドレスは `docker-compose.yml` の `mysql` の項目に設定したIPになります。  
上記は実装例通りに設定した場合です。  

変更したらFatJarをビルドして出来上がったJarファイルをコピーしてコンテナをビルドし直しましょう。  
`docker-compose build kotlin`  
でビルドできます。  

### Dockerがうまく動作しない時は

以下のポイントをチェックしてみましょう。  

- kotlinサーバーの `UserRepository.kt` に設定されているmysqlのIPは `docker-compose.yml` に記載されているIPと同じですか？
- kotlinサーバーの `UserRepository.kt` に設定されているmysqlのパスワードは `docker-compose.yml` に記載されているパスワードと同じですか？
- 上記を確認したらFatJarを再度作り直してDockerのイメージをビルドし直してみましょう
- それでも駄目な場合、 `docker-compose.yml` に書かれている設定と違う設定でmysqlのデータベースが作成されている可能性があるので下記操作をしましょう
    - 下記作業をするとデータは消えます
    - `./MySqlDocker/data` 配下にファイルがある場合、全て削除してから再度mysqlのDockerを立ち上げ直す
    - 無い場合は別の箇所にDBデータが保存されているので、 `docker-compose rm mysql` で削除してから再度立ち上げ直す

## Reactを書いてみよう

### Reactのプロジェクトを作成しよう

Reactのプロジェクトを簡単に生成するために以下が必要となります。  

- npm

npmはNode.jsのパッケージマネージャーですが、今やReact.jsやVue.jsのツールチェーンなどもカバーしています。  
フロントエンドエンジニアもお世話になっている方が多いでしょう。  
なお、後発の `yarn` と言うツールもあります。  
`yarn` は `npm` のインストール速度が遅いなどの問題を解決していますので、こちらを使用してもよいでしょう。


#### React用のコンテナを作成

```dockerfile
FROM node:tag
```

```yaml
  node:
    build: Dockerfileが入っているディレクトリを指定
    image: image_name:tag
    ports:
      - "host_port:container_port"
    networks:
      virtual_network:
        ipv4_address: IPアドレス
    container_name: 実行中のコンテナの名前
    # 環境変数の設定
    volumes:
      - host_directory:container_directory
```

#### Reactアプリを生成しよう

まずはReactのテンプレートを公式のツールを使って生成してみましょう。  

`npx create-react-app react-sample-app`  

上記コマンドをdocker経由で実行したいので、 `docker-compose run container command` コマンドを使って上記コマンドを実行しましょう。  

`docker-compose run react npx create-react-app react-sample-app`  

上記コマンドを実行すると、自動でReactのサンプルアプリケーションを生成してくれます。  
既に実行可能な状態にセットアップされているため、先ずはサンプルを実行してみましょう。  

`docker-compose run react yarn start`  

上記コマンドでサーバーが立ち上がり、リクエスト受付状態になります。  
ローカル環境の場合ブラウザまで立ち上げてくれますが、そうでない場合は下記アドレスにアクセスしましょう。  
`http://localhost:3000`

止める時は `Ctrl+C` で終了します。  

#### FormatterとLinterを入れよう

Formatterはコードのフォーマットを一定のルールに従ってフォーマットしてくれる大変便利なツールです。  
JavaScriptでは以下のフォーマッターがよく使われている様です（筆者はPrettierを使用した経験あり）。  

- [Prettier](https://prettier.io/)
    - 様々な言語に対応
    - オプション少なめ
        - これはOpinionatedと言っている通り、そもそもオプションをあまり用意しない方針
    - ESLintと連携可能
- [JS Beautifier](https://github.com/beautify-web/js-beautify)
    - オプションがPrettierより多い様ですが、申し訳ありませんが差分まで把握していません
    - VS Codeの標準のフォーマッターがこちらベースらしい

今回は設定が少ないためセットアップの手間が少ないPrettierを使います。  

Linterは以下がよく使われている様です（筆者はESLintを使用した経験あり）。  

- [ESLint](https://eslint.org/)
    - プラグインベースで多種多様なルールを追加可能
    - Reactで使われるJSXにも対応可能
    - Formatterとしても使用可能
        - Prettierと併用する場合はPrettierのプラグインを追加する
    - 下記のLinterよりは動作が遅い
- [JSLint](https://www.jslint.com/help.html)
    - Douglas Crockford’s Javascript: The Good Partsがベースになっているらしい
    - オプションはあまり用意されていない
- [JSHint](https://jshint.com/)
    - JSLintよりはオプションで色々と設定が可能とのこと

今回はReactのプロジェクトということもあり、ESLintを使用します。  

下記コマンドでPrettierとESLintをインストールします。  
`-D` オプションは `devDependencies` に追加するためのオプションです。  
これはnpmの仕組みが本番用のライブラリと開発用のライブラリが分かれており、開発時にしか影響しないような以下のライブラリは開発用に登録することになっているからです。

- Formatter
- Linter
- テスト用のライブラリ
- ビルド用のツール

[doc](https://docs.npmjs.com/specifying-dependencies-and-devdependencies-in-a-package-json-file)  

本番用と開発用に分けて登録しておくと、 `npm` にモジュールを登録した時に本番用のライブラリのみインストールされるようになります。

`yarn add -D prettier eslint`

先程記述した通り、eslintはプラグインベースです。  
ReactとPrettierのプラグインを追加しましょう。  

`yarn add -D eslint-plugin-react eslint-plugin-prettier`

ここで `package.json` を見てみましょう。  
インストールしたライブラリのバージョンの先頭に `^` が付いていると思います。  
これは `major.minor.patch` のバージョン記法の場合、  **最新のminorとpatchバージョンを取得する** という記法です。   
ですので、npmでは基本的には **minorバージョンまでの変更はBreaking changeは含まない** のが普通となっています。  
また、 `patch` まで最新バージョンにしたい場合は `~` を付ける記法もあります。  

- `^` - その時点のminor、patchの最新を取得
- `~` - その時点のpatchの最新を取得

どちらにしてもこれらの記法を使うと `yarn install` や `npm install` した時点でのルールに則った最新バージョンを取得するため、ライブラリにバグ等あった場合
影響があるので注意しましょう。  
`^` や `~` を付けなければ指定された通りのバージョンを取得します。  

しかし当然ながらこのままだといきなり本番で新しいバージョンのライブラリがインストールされて不具合を起こした、ということになりかねません。  
ですので使用中のバージョンを固定する仕組みがちゃんとあります。  

- `yarn` を使用している場合は `yarn.lock`
- `npm` を使用している場合は `package-lock.json`

と言うファイルが作成されているはずです。  
これらはインストールした時点でのライブラリの依存関係とバージョン番号が記載されていて、 `yarn install` や `npm install` した時にこれらのlockファイルが
ある場合はそちらに記載されているバージョンをインストールする仕組みとなっているので、必ず一意なバージョンとなります。  
これらのファイルも忘れずにレポジトリで管理しましょう。  
 

#### ユーザーの一覧リスト表示画面を作成してみよう

以下の様な機能を実装してみましょう。  

1. ページを開く
1. Ktorで作成したAPIからリストを取得する
1. 一覧をテーブルで表示する

##### ページを開く

今の状態だとサーバーにアクセスするとサンプルのページが開かれます。  
自分の作ったページを表示したい場合はどうすればよいでしょうか。  

サンプルのReactの場合、 `public/index.html` と `src/index.js` がページのエントリーポイントとなっています。  
この2つのファイルを確認すると、 `index.html` 内の `root` 要素に `index.js` が `<App />` を描画しているということが読み取れます。  
この `<App />` がReactのコンポーネントであり、実態は `App.js` に書かれています。  

`App.js` を書き直してもよいのですが、今回は学習のため自作のコンポーネントを1から作成してみましょう。  
 
ここでVS Codeを使用している場合は以下のプラグインをインストールしましょう。  

- Reactjs code snippets

IntelliJ系の場合は以下のプラグインをインストールしましょう。  

- React snippets

これは定型的なコードを簡単に記載するためのスニペットのプラグインです。  
どちらも `rcc` と入力するとReactのコンポーネントのスケルトンが候補として表示されるので、選択すると展開されます。   
`UserList.js` というファイルを作成して以下のコードを入力してみましょう。  

```javascript
import React, { Component } from "react";

class UserList extends Component {
  render() {
    return <div>Hello, World!</div>;
  }
}

export default UserList;
```

`render()` のところに書かれている `return <div>Hello, World!</div>;` というのはJSXというReact独自の構文です。  
HTMLをそのまま書き込めるのが特徴ですが、当然ながら標準のJavaScriptの機能ではないため注意してください。  

`index.js` も修正が必要です。  
先ほど作成した `UserList.js` をimportしましょう。

`import UserList from "./UserList";`

描画しているコンポーネントも `<App />` から `<UserList />` に変更しましょう。

`ReactDOM.render(<UserList />, document.getElementById("root"));`

再度 `yarn start` でサーバーを立ち上げましょう。  

`Hello, World!` と表示されていれば成功です。  
ちなみにこちらのサーバーはホットリロードが有効になっているため、ソースを修正すれば即時反映されます。  

##### Ktorで作成したAPIからリストを取得する

APIを呼び出してKtorからデータを取得しましょう。  
JavaScriptでは小さな機能を持ったライブラリを組み合わせて機能を実現するという考え方が一般的です。  
標準のやり方でもAPI通信は可能ですが、今回は [axios](https://github.com/axios/axios) というライブラリを使用しましょう。  
`axios` を使用することでAPIリクエストを簡潔に記載することが出来ます。  

ライブラリを使用しない標準のXMLHttpRequestを使用したリクエストのやり方は以下のURLを参考にしてみてください。  
https://developer.mozilla.org/ja/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest

ここからReactの仕組みを含めて説明します。  

Reactは名前の通りReactive（反応する）な振る舞いをします。  
よく例として上げられるのは、Excel等の表計算ソフトに計算式を入れて、データ取得元のセルの値が変わると即座に結果が変更されるという動作です。  
Reactは上記の様なことが簡単に実現できるようになっています。  

Reactは下記の2つの値がよく使用されるため、どういった時に使われるものか把握しておきましょう。  

- prop
    - 親からComponentへ値を受け渡すために使用する
    - 値は変更不可
- state
    - 状態保持用
    - 値は変更可能
    - stateが変更されたことが通知されると影響がある箇所のみ再描画してくれる
    
参考: https://reactjs.org/docs/faq-state.html#what-is-the-difference-between-state-and-props  

上記を踏まえてコンストラクタを記載しましょう。  

```javascript
  constructor(prop) {
    super(prop);
    this.state = {
      users: []
    };
  }
```

これでstateに `users` というArrayが初期化されて作成されました。  
次は `users` にAPIから取得した値をセットしましょう。  

Reactにはライフサイクルがあります。  
以下の関数を用意しておくことで、それぞれの状態の時に実行したい処理が実行されます。  

- `componentDidMount()`
    - Componentがマウントされた時（読み込まれた時）に実行
- `componentDidUpdate()`
    - Componentがstateの変更などでアップデートされた時に実行
- `componentWillUnmount()`

上記は代表的なライフサイクルのメソッドで、それ以外にもいくつか特定の状況の時に呼び出されるメソッドがあります。  
詳しくは下記を参照してください。  
https://reactjs.org/docs/react-component.html  

今回は画面を表示する際にAPI通信をして取得した値を表示するという処理になるので、 `componentDidMount()` に処理を記載します。  

```javascript
  componentDidMount() {
    axios.get("http://localhost:8080/users").then(response => {
      this.setState({
        users: response.data
      });
    });
  }
```

これでstateにAPIから取得したJSONがセットされます。  
ひとまず取得した値を表示してみましょう。  

```javascript
  render() {
    return (
      <dev>
        {this.state.users.map(user => {
          return (
            <p>
              {user.id}
              {user.firstName}
              {user.lastName}
              {user.gender}
              {user.age}
            </p>
          );
        })}
      </dev>
    );
  }
```

`map` を使って `this.state.users` 内の値を全てループして表示します。 　
不格好ですがデータの取得まで出来ていることが確認できました。  

##### 一覧をテーブルで表示する

それでは最後に表示するデータをテーブルに整形しましょう。  
`render()` を以下のように書き換えてください。  

```javascript
  render() {
    return (
      <table>
        <tbody>
          <tr>
            <th>id</th>
            <th>first name</th>
            <th>last name</th>
            <th>gender</th>
            <th>age</th>
          </tr>
          {this.state.users.map(user => {
            return (
              <tr>
                <td>{user.id}</td>
                <td>{user.firstName}</td>
                <td>{user.lastName}</td>
                <td>{user.gender}</td>
                <td>{user.age}</td>
              </tr>
            );
          })}
        </tbody>
      </table>
    );
  }
```

これでテーブルで全データを表示することが可能になりました。  
しかしこの書き方だと毎回全件のデータを取得することになるため、数万件規模の大量のデータがある場合はブラウザがクラッシュするかもしれません。  
実環境ではきちんとページングの処理を追加することを検討しましょう。  

#### React routerを導入しよう

一画面実装することができましたが、実際のアプリでは複数画面を実装して画面間を行き来できるようにする必要があります。  
画面間を行き来出来るように [react-router-dom](https://www.npmjs.com/package/react-router-dom) を導入しましょう。  

`yarn add react-router-dom`  

`react-router-dom` は高機能ですが、今回は以下の書き方を理解すれば大丈夫です。  

```html
<Router>
    <div>
       <Link to="/path">XXXX</Link>
       <Route path="/path" component={Component} />
     </div>
</Router>
```

`<Link></Link>` でリンクを作成して、 `<Route />` でURLのパスが一致する時に指定したcomponentを表示するというのが `Router` の基本的な処理です。  
まずはツールバーを作ってみましょう。  
ツールバーには `UserList.js` のリンクを設定しましょう。  

```javascript
import React, { Component } from "react";
import { BrowserRouter as Router, Route, Link } from "react-router-dom";
import UserList from "./UserList";

class ToolBar extends Component {
  render() {
    return (
      <Router>
        <div>
          <Link to="/list">User List</Link>
          <Route path="/list" component={UserList} />
        </div>
      </Router>
    );
  }
}

export default ToolBar;
```

`ToolBar` を直接 `index.js` で指定しても動作するのですが、今後様々なComponentを組み合わせることを想定して `TopComponent.js` でラップしましょう。  

```javascript
import React, { Component } from "react";
import ToolBar from "./ToolBar";

class TopComponent extends Component {
  render() {
    return (
      <div>
        <ToolBar />
      </div>
    );
  }
}

export default TopComponent;
```

これを `index.js` に設定します。  

```javascript
import TopComponent from "./TopComponent";

ReactDOM.render(<TopComponent />, document.getElementById("root"));
```

これで実行するとリンクが表示され、リンクをクリックするとリストが表示されるようになりました。  

#### ユーザー追加ページを作ろう

次はユーザー作成APIを利用して、ユーザー作成ページを作りましょう。  

ユーザー作成コンポーネント用の `CreateUser.js` を作成しましょう。  

さて、ここでどのようなページを作成すればよいかを考えてみましょう。  

1. ユーザー登録フォームに情報を入力
1. 登録ボタンを押す
1. APIが呼び出されて登録される

上記のような流れが考えられます。  
では、順に作成しましょう。  

スケルトンは `rcc` で作成済みとします。  
`render()` にHTMLを記載しましょう。  

```javascript
  render() {
    return (
      <div>
        <form name="userDataForm">
          First Name:
          <input
            type="text"
            name="firstName"
            value={this.state.firstName}
            onChange={this.handleFirstNameChange}
          />
          <br />
          Last Name:
          <input
            type="text"
            name="lastName"
            value={this.state.lastName}
            onChange={this.handleLastNameChange}
          />
          <br />
          Gender:
          <select
            name="gender"
            value={this.state.gender}
            onChange={this.handleGenderChange}
          >
            <option value="1">Man</option>
            <option value="2">Woman</option>
            <option value="3">Other</option>
          </select>
          <br />
          age:
          <input
            type="number"
            name="age"
            value={this.state.age}
            onChange={this.handleAgeChange}
          />
          <br />
          <button type="button" onClick={this.submitUserData}>
            submit
          </button>
        </form>
        <div>{this.state.result}</div>
      </div>
    );
  }
```

単純なフォームを作成しました。  
ここでポイントは3つあります。  
1. `button` の `onClick` に `this.submitUserData` を割り当てている点
    - `button` を押すと `submitUserData()` が呼び出される
1. 各 `input` にそれぞれ `onChange` が設定されている点
    - 値が変化した時に `onChange` に割り当てた関数が実行される
1. 各 `input` にそれぞれ `value` が設定されている点
    - `state` が変化した時に自動的に反映される

次は `state` の初期値を設定してから各 `input` の `onChange` の関数の実装をしましょう。  

```javascript
  constructor(prop) {
    super(prop);
    this.state = {
      firstName: "",
      lastName: "",
      gender: 1,
      age: 20,
      result: "Please submit data."
    };
  }
``` 

これで初期値が設定されました。  
次は各 `onChange` の実装です。  

```javascript
  handleFirstNameChange = e => {
    this.setState({ firstName: e.target.value });
  };

  handleLastNameChange = e => {
    this.setState({ lastName: e.target.value });
  };

  handleGenderChange = e => {
    this.setState({ gender: e.target.value });
  };

  handleAgeChange = e => {
    this.setState({ age: e.target.value });
  };
```

アロー関数で記載しました。  
`state` を変更する時は必ず `this.setState()` を使います。  
直接値をセットしても変更が通知されないので、再描画されないということになってしまいます。  
気を付けてください。  

これで値を変更した時にstateに値がセットされるようになりました。  
最後にこの値を使ってユーザー登録APIを呼び出しましょう。  

```javascript
  submitUserData = () => {
    axios
      .post("http://localhost:8080/users", {
        firstName: this.state.firstName,
        lastName: this.state.lastName,
        gender: this.state.gender,
        age: this.state.age
      })
      .then(response => {
        console.log(response);
        this.setState({ result: "Success!" });
      })
      .catch(error => {
        console.log(error);
        this.setState({ result: "Error!" });
      });
  };
```

ここで注意してほしいのはJavaScriptでは `function(){}` と `function = () => {}` はイコールではないという点です。  
従来の `function(){}` では `this` は関数ごとに持っていたため、function内で `this.setState()` を呼び出しても `this.setState()` が存在しませんでした。  
そのため、 `this` を束縛するためにコンストラクタ内で `this.function = this.function.bind(this);` と書いて、 `this` を束縛した状態にする（クラス内の `this` と同じ状態にする）必要がありました。  
しかし、これがオブジェクト指向プログラミングをする際に厄介だったため、アロー関数は `this` を持たないようになりました。  
代わりに現在のスコープ内での値を探し、無い場合は1つ外側のスコープを探す、といった動作をするようになります。  
そのため、アロー関数ではコンストラクタで `bind` する必要がなくなりました。  
アロー関数の `this` の動作はJavaの `this` の動作に近いため、多言語からJSに来た方はこれらの問題は基本的にアロー関数を使うことによって避けられます。  

詳しくは下記URLを見てください。  
https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Functions/Arrow_functions

実装が終わったら、ユーザー作成ページへのリンクを追加しましょう。  

`ToolBar.js` の `rendar()` 関数に `CreateUser.js` のリンクを追加してあげましょう。  

```javascript
import CreateUser from "./CreateUser";

...

  render() {
    return (
      <Router>
        <div>
          <Link to="/list">User List</Link>&nbsp;
          <Link to="/create">Create User</Link>
          <Route path="/list" component={UserList} />
          <Route path="/create" component={CreateUser} />
        </div>
      </Router>
    );
  }
```

APIサーバーを起動してちゃんと動作するか確かめてみましょう。  

#### ユーザーの検索フォームを作成してみよう

検索APIを使用して検索フォームを実装してみましょう。  
ユーザーリストとユーザー作成を参考にすれば簡単に実装可能なので、先ずは自力で挑戦してみるとよいでしょう。  

コードの例は以下です。  

```javascript
import React, { Component } from "react";
import axios from "axios";

class SearchUser extends Component {
  constructor(props) {
    super(props);
    this.state = { id: null, user: null, result: "Please enter ID." };
  }

  handleIdChange = e => {
    this.setState({ id: e.target.value });
  };

  searchUserData = () => {
    axios
      .get("http://localhost:8080/user/" + this.state.id)
      .then(response => {
        console.log(response);
        this.setState({ user: response.data, result: "Success!" });
      })
      .catch(error => {
        console.log(error);
        this.setState({ result: "Error!" });
      });
  };

  render() {
    return (
      <div>
        <form>
          <input type="number" name="id" onChange={this.handleIdChange} />
          <button type="button" onClick={this.searchUserData}>
            search
          </button>
        </form>
        <div>{this.state.result}</div>
        {this.state.user && (
          <table>
            <tbody>
              <tr>
                <th>id</th>
                <th>first name</th>
                <th>last name</th>
                <th>gender</th>
                <th>age</th>
              </tr>
              <tr>
                <td>{this.state.user.id}</td>
                <td>{this.state.user.firstName}</td>
                <td>{this.state.user.lastName}</td>
                <td>{this.state.user.gender}</td>
                <td>{this.state.user.age}</td>
              </tr>
            </tbody>
          </table>
        )}
      </div>
    );
  }
}

export default SearchUser;
```

### Bootstrapを使ってみよう

画面は実装出来ましたが見栄えはイマイチですので、Bootstrapを適用してモダンな見た目にしてみましょう。  
BootstrapはCSSとJSのライブラリですが、今回はCSSを使用します。  

[Bootstrap](https://getbootstrap.com)はフロントエンド向けのコンポーネントライブラリです。  
簡単にモダンな見た目のサイトを作れます。  
Sassの変数やmixinを使ったり、レスポンシブなグリッドシステムや、拡張可能なビルド済みのコンポーネントなどを使えます。  
今回はあまり複雑なことはせず、グリッドやコンポーネントを利用しましょう。  

#### ToolBarにCSSを適用しよう

[こちらのサンプル](https://getbootstrap.com/docs/4.3/examples/navbar-static/)みたいなツールバーにしてみましょう。  
サンプルのソースは[こちら](https://getbootstrap.com/docs/4.3/examples/)からダウンロード可能です。  

また、Nabbarを使う場合はこちらに説明が書いてありますので、より詳しく知りたい場合はこちらを見るとよいでしょう。  
[Nabbar](https://getbootstrap.com/docs/4.3/components/navbar/)  

サンプルのソースを見ると、ナビゲーションバーは `<nav>` 要素で囲まれていて、その中には `<ul>` 要素でリストが作成されていることが分かります。  
`<nav>` には `"navbar navbar-expand-md navbar-dark bg-dark mb-4"` が指定されています。  

まず、 Navbarを使用する場合は `navbar` と `navbar-expand{-sm|-md|-lg|-xl}` をセットで使用することでレスポンシブな折り畳みが有効になり、かつカラースキームクラスの使用が可能になります。  
`navbar` のみだと要素が縦に並んでしまいます。  
`navbar-expand{-sm|-md|-lg|-xl}` の違いは、ブラウザのサイズを縮めた時にどのサイズまで縮めたら折りたたむかを指定します。  
何も付けない場合は折りたたみません。  
一行で表示するように、各要素を複数行で表示する動作となります。  
`{-sm|-md|-lg|-xl}` は指定されたサイズまでブラウザサイズが縮まると、要素が縦に並びます。  
各要素を横に並べた時に入りきるサイズを指定しましょう。  
これらの動きは文字では分かりにくいと思うので、実際に試してみると理解が深まります。  

`navbar-dark` は各要素の文字色を白くするクラスです。  
Navbarの背景色を濃い色にする時に使いましょう。  
逆に各要素の文字色を黒くしたい場合は `navbar-light` を使用しましょう。  

`bg-dark` は背景色を黒くするクラスです。  
`bg-` にはいくつか別のクラス（ `bg-primary` など）も用意されています。   

`mb-4` はmargin bottomの意味です。  
[こちら](https://getbootstrap.com/docs/4.3/utilities/spacing/)に詳しく説明されています。  

m（margin）とp（padding）に、t（top）、b（bottom）、l（left）、r（right）x（leftとright両方）、y（topとbottom両方）、空白（4方向全て）を組み合わせて使用します。  
後ろの数字は大きさで、基本的には0（マージン無し）〜5までと `auto` があり、数字が大きくなるほどスペース幅が大きくなります。  

Navbar内ではいくつかの便利なサブコンポーネントがサポートされています。  
詳しくは[ドキュメント](https://getbootstrap.com/docs/4.3/components/navbar/#supported-content)を確認してください。  
今回は `navbar-nav` を使います。  
`navbar-nav` は、ナビゲーションバー内の高さを使い切る、ドロップダウンをサポートした軽量なサブコンポーネントです。  



Navbar内の各要素を並べるのに `<ul>` と `<il>` タグを使用します。  


```javascript


```

#### ユーザーの登録フォームにCSSを適用しよう

#### ユーザーの一覧リスト表示画面にCSSを適用しよう

#### ユーザーの検索フォームにCSSを適用しよう


### Slackに通知してみよう

## ngrokを使ってみよう

